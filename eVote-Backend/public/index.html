<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Blockchain E-Voting | Bifeldy</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js"></script>
  </head>
  <body>
    <h1>Basilius Bias Astho Christyono</h1>
    <h2>000.000.13536</h2>
    <h3>Server Untuk Autentikasi User E-Voting</h3>
    <h4>// DONE: Create Distributed Peer-to-Peer Client Connections</h4>
    <h5>// TODO: Create Blockchain Data Structure</h5>
    <h5>// TODO: Create Authentication Server API (Login, Regist, etc.)</h5>
    <h5>// TODO: Create Angular / Ionic Apps (Hybrid-Mobile-WebDesktop)</h5>
    <script>

      const xClientId = prompt(
        'Enter x-client-id !',
        `x-client-id-is-up-to-you-user-${Math.floor(Math.random() * 10)}`
      );
      const socketIoNetwork = 'localhost:80';
      const peersJsNetwork = {
        host: 'localhost', port: 81, path: '/peers',
      };

      let mySocket = null;
      let mySocketNodes = [];

      let myPeer = null;
      let myPeerConnection = [];
      let myPeerNodesOut = [];
      let myPeerNodesIn = [];
      let myPeerMaxConnectionsOut = 5;

      const socketIo = io(socketIoNetwork, {
        transportOptions: {
          polling: {
            extraHeaders: {
              'x-client-id': xClientId
            }
          }
        }
      });

      /********** ********** ********** ********** ********** ********** ********** ********** ********** **********/

      socketIo.on('connect', () => {
        console.log(`[SOCKET_CONNECTED] Connected To The Socket Server Tracker`);
      });
      socketIo.on('disconnect', reason => {
        console.log(`[SOCKET_DISCONNECTED] ${reason.replace(/\b[a-zA-Z]/g, str => str.toUpperCase())}`);
        if(reason == 'io server disconnect') socketIo.connect();
      });
      socketIo.on('reconnecting', attemptNumber => {
        console.log(`[SOCKET_RECONNECTING] Reconnecting.. ${attemptNumber} Attempt`);
      });
      socketIo.on('reconnect', attemptNumber => {
        console.log(`[SOCKET_RECONNECTED] Reconnected After ${attemptNumber} Attempt`);
        if(myPeer) PeerJsCreateConnectionOut();
      });
      socketIo.on('ping', () => {
        console.log(`[SOCKET_PING] Pinging Server..`);
      });
      socketIo.on('pong', latency => {
        console.log(`[SOCKET_PONG] Pong! Latency :: ${latency}ms`);
      });
      socketIo.on('error', error => {
        console.log(`[SOCKET_ERROR] ${error.message}`);
      });

      socketIo.on('client-id', socketInformation => {
        mySocket = socketInformation;
        console.log(`[SOCKET_INFORMATION] My Socket ClientId :: ${mySocket.socketClientId}`);
        if(!myPeer) {
          const peer = new Peer(mySocket.socketClientId, {
            host: peersJsNetwork.host, port: peersJsNetwork.port, path: peersJsNetwork.path,
            config: {
              'iceServers': mySocket.socketIceServer
            }
          });
          myPeer = peer;
          PeerJsStartedAndReady();
        }
      });

      socketIo.on('add-or-remove-nodes', nodes => {
        mySocketNodes = nodes.filter(myScktNds => myScktNds.socketClientId != mySocket.socketClientId);
        console.log(`[SOCKET_NODES-UPDATED] Total Other Nodes :: ${mySocketNodes.length}`);
      });

      /********** ********** ********** ********** ********** ********** ********** ********** ********** **********/

      function ShuffleArray(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;
        while (0 !== currentIndex) {
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex -= 1;
          temporaryValue = array[currentIndex];
          array[currentIndex] = array[randomIndex];
          array[randomIndex] = temporaryValue;
        }
        return array;
      }

      function PeerJsStartedAndReady() {
        myPeer.on('open', peerId => {
          console.log(`[PEER_OPENED] My PeerId :: ${peerId}`);
          PeerJsCreateConnectionOut();
        });
        myPeer.on('disconnected', () => {
          console.log('[PEER_DISCONNECTED] Connection To Peer Server Tracker Loss');
        });
        myPeer.on('connection', conn => {
          console.log(`[PEER_INCOMING-CONNECTION] Connection From PeerId :: ${conn.peer}`);
          ConnectionHandler(conn, 'connection-in');
        });
        myPeer.on('error', error => {
          console.log(`[PEER_ERROR] ${error.message}`);
        });
      }

      function PeerJsCreateConnectionOut() {
        if(mySocketNodes.length > 0 && myPeerNodesOut.length <= myPeerMaxConnectionsOut) {
          console.log(`[PEER_FINDING] Finding Nework Peers`);
          const myPeerNodesShuffle = ShuffleArray(mySocketNodes);
          for (let i = 0; i < myPeerNodesShuffle.length; i++) {
            const myPeerNodesOutIdx = myPeerNodesOut.findIndex(prNds => prNds == myPeerNodesShuffle[i].socketClientId);
            const myPeerNodesInIdx = myPeerNodesIn.findIndex(prNds => prNds == myPeerNodesShuffle[i].socketClientId);
            if(myPeerNodesOutIdx >= 0 || myPeerNodesInIdx >= 0) continue;
            else if(myPeerNodesOut.length >= myPeerMaxConnectionsOut) break;
            else {
              console.log(`[PEER_OUTGOING-CONNECTION] Connecting To PeerId :: ${myPeerNodesShuffle[i].socketClientId}`);
              myPeerNodesOut.push(myPeerNodesShuffle[i].socketClientId);
              const conn = myPeer.connect(myPeerNodesShuffle[i].socketClientId);
              ConnectionHandler(conn, 'connection-out');
            }
          }
        }
      }

      function ConnectionHandler(conn, type) {
        conn.on('open', () => {
          if(type == 'connection-in') myPeerNodesIn.push(conn.peer);
          myPeerConnection.push(conn);
          console.log(`[PEER_CONNECTED] Connected To PeerId :: ${conn.peer}`);
          conn.on('data', data => { ConnectionDataHandler(conn, data); });
          conn.on('error', error => { ConnectionErrorHandler(conn, error); });
          conn.on('close', () => { ConnectionCloseHandler(conn); });
        });
      }

      function ConnectionDataHandler(conn, data) {
        console.log(`[PEER_DATA] ${conn.peer} :: ${data}`);
      }

      function ConnectionErrorHandler(conn, error) {
        console.log(`[PEER_ERROR] ${conn.peer} :: ${error.message}`);
      }

      function ConnectionCloseHandler(conn) {
        myPeerNodesIn = myPeerNodesIn.filter(prCnn => prCnn != conn.peer);
        myPeerNodesOut = myPeerNodesOut.filter(prCnn => prCnn != conn.peer);
        myPeerConnection = myPeerConnection.filter(prCnn => prCnn.peer != conn.peer);
        console.log(`[PEER_CLOSED] Connection Closed From PeerId :: ${conn.peer}`);
      }

    </script>
  </body>
</html>